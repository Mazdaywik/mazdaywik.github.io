_Александр Коновалов, сентябрь 2018_

Интертрепатор, снижающий сложность
==================================

В ходе обсуждения дистилляции с коллегами сложилась идея интерпретатора,
который может исполнять некоторые программы с меньшей алгоритмической
сложностью, нежели при прямолинейной интерпретации.

Изложение в данной работе будет вестись, как и прежде, **на интуитивных
основаниях,** но при этом промежуточные выкладки я буду стараться делать
строго формально, максимально избегаяя каких-либо натяжек.

Дальнейшее изложение будет вестись, как и в [предыдущей работе](essay.md),
в терминах перестановочного Рефала. И как и прежде, перестановочный Рефал
будет поддерживать многоместные функции как синтаксический сахар.

Обычный интерпретатор Рефала имеет две области памяти: поле программ, которое
не меняется при вычислениях, и поле зрения, описывающее текущее состояние
вычислений. Интерпретатор работает по шагам, заменяя на каждом шаге в поле
зрения активный вызов на его результат (согласно правилам, описанным в поле
программ). Вычисления завершаются, когда результат в поле зрения пассивен —
вызовов функций больше нет.

А если наоборот: написать интерпретатор, у которого в поле зрения ничего
интересного нет, но на каждом шаге переписывается поле программ?

> Сидит еврей, думает. Подходит другой еврей.<br/>
> — Ты о чём думаешь?<br/>
> — Я думаю, зачем в слове «Мойша» буква «р».<br/>
> — Так её же там нет.<br/>
> — А если вставить?<br/>
> — А зачем?<br/>
> — Вот и я думаю: зачем?<br/>

Зачем писать такой интерпретатор? Размышления показывают, что он будет
обладать некоторыми интересными свойствами.

Аргументами интерпретатора являются начальное состояние поля зрения и исходная
программа:

    <Int  .......... , ....... >
          view-field   program

Для простоты будем считать, что интерпретатор по соглашению начинает своё
выполнение с функции `Go`, которая вызывается с некоторым аргументом:

    <Int ........ , ....... >
         <Go arg>   program

Обычный интерпретатор Рефала в данном случае стал бы переписывать поле зрения,
меняя на каждой итерации первый аргумент и сохраняя второй констатным.

Наш будет действовать иначе (почему? потому!). Он будет подготавливать программу
идеально к каждому следующему шагу. Как? Суперкомпиляцией. Но, если
суперкомпилятору «скормить» программу с константным аргументом, остаточная
программа просто будет функцией `Go`, возвращающей константу. Чтобы
суперкомпилятор выдал нетривиальную остаточную программу, нужно скормить ему
программу с параметрами. Поэтому интерпретатор вводит параметры:

    <Int-Loop (... ← ...) , <Scp ........ , ....... >>
               arg   e.0         <Go e.0>   program

Суперкомпилятор порождает некоторую остаточную программу. Поскольку на первой
(а вернее, на нулевой) итерации программа специализировалась в общем положении,
результат суперкомпиляции может оказаться тривиальным — с точностью до порядка
и переименования функций и переменных совпадать с исходной программой.

Но смотрим, что дальше делает `Int-Loop`:

    <Int-Loop (.........) , ........ , ........ >
               arg ← e.0    <F1 e.0>   program0

`Int-Loop` видит некоторую остаточную программу и точку входа в неё — функцию,
которая зависит от входного параметра. Возможны три случая:

1. Функция `F1` состоит из единственного предложения с пассивной правой
   частью. В этом случае интерпретатор просто подставляет в правую часть
   значение параметра и возвращает результат подстановки как результат.
2. В функции `F1` есть ветвление по различным сужениям параметра `e.0`.
3. В функции `F1` нет ветвления ни по какому из параметров (позже покажем,
   что параметров может быть несколько).

**В первом случае** мы имеем остановку интерпретатора с выдачей ответа.

**Второй случай** интереснее. В остаточной программе параметр `e.0` будет падать
в функцию, где по нему будут выполняться одно или несколько сужений. Поскольку
мы используем перестановочный Рефал, все эти сужения будут независимы. Пусть
они имеют вид

    e.0 → P1
    e.0 → P2
    . . .
    e.0 → Pn

Интерпретатор применяет каждое из них к актуальному аргументу `arg`:

    arg : P1
    arg : P2
    . . .
    arg : Pn

Успешно может разрешиться не более одного клэша из нескольких. Если
не выполнился ни один, интерпретатор сообщает об ошибке невозможности
отождествления — аргумент не входит в область определения программы.

Успешно разрешившийся клэш присвоит значения переменным, входящим в `Pi`:

    arg1 ← v.1
    arg2 ← v.2
    . . .
    argK ← v.K

(Здесь `v` — это `s`, `t` или `e`.) Эти переменные и будут новыми параметрами,
а образец `Pi` — аргументом функции `F1` на следующую суперкомпиляцию:

    <Int-Loop (.... ← ...) … (.... ← ...) , <Scp ....... , ........ >>
               arg1   v.1     argK   v.K         <F1 Pi>   program0

    <Int-Loop (.... ← ...) … (.... ← ...), ................ , ........ >>
                                           <F1 v.1, …, v.K>   program1

В предельном случае `K` может оказаться равным нулю — образец `Pi` не содержит
переменных. В этом случае следующая суперкомпиляция просто проинтерпретирует
программу на константных данных и построит тривиальную программу из одного
предложения с пассивной правой частью. Этот случай соответствует корректной
остановке интерпретатора, мы его уже рассматривали.

Наконец, **третий случай** — сужений на параметры нет. Одной из причин может
быть бесконечная рекурсия вида

    Fi {
      EXPR = <Fi EXPR>
    }

В идеале суперкомпилятор должен обнаруживать в графе бесконечную рекурсию
и такие ветви отсекать. В таком случае интерпретатор будет видеть, что
граф (остаточная программа) пустой и выдавать сообщение об ошибке.

Другая причина — кривое обобщение, которое может быть как в корректной
программе, так и в зацикливающейся. Что может делать интерпретатор? Проще
всего «белый флаг» и начинать интерпретировать программу «по простому».
Либо искать какое-нибудь более интеллектуальное решение, например, строить
бесконечное дерево процесса до ближайшего ветвления. Понятно, что в обоих
случаях интерпретатор на зацикливающейся программе зависнет.

Можно ли научить суперкомпилятор никогда не обобщать входные параметры,
чтобы избежать третьего случая? Можно, но тогда сам суперкомпилятор рискует
зациклиться _(доказать не могу, чисто интуитивное предположение)._

В последующих примерах третий случай никогда не будет возникать. Рассмотрим
эти примеры.

### Соглашение о нотации MST-схем

Если аргументы функций на разных этажах схемы короткие, то их легко
изображать в строчку:

    <Int ........ , ....... >
         <Go arg>   program

Но если аргументы длинные, то схема удлиняется и перестаёт влезать в ширину
страницы:

    <Int ............................. , .................................. >
         <StartPointFunction argument>   the-better-program-for-interpreter

Строчки нижних этажей — это метакодированные выражения. Можно, используя
альтернативную нотацию (также представленную в текстах Турчина), записывать
так:

    <Int ↓{ <Go arg> }, ↓{ program }>

    <Int
      ↓{ <StartPointFunction argument> }
      ,
      ↓{ the-better-program-for-interpreter }
    >

Я буду записывать длинные метакодированные аргументы как строки, начинающиеся
со знака стрелки вниз, без фигурных скобок:

    <Int
      ↓ <StartPointFunction argument>
      ,
      ↓ the-better-program-for-iterpreter
    >

В последующих разделах нам потребуются приподнятые переменные:

    <Int ... e.X . , ....... >
         <Go  •  >   program

В «вертикальной нотации» приподнятые переменные будут окружаться знаками `#`:

    <Int
      ↓ <StartPointFunction #e.X#>
      ,
      ↓ the-better-program-for-interpreter
    >

Рекурсивное вычисление чисел Фибоначчи
--------------------------------------

Рассмотрим следующую программу:

    Go { e.N = <Fib e.N>; }

    Fib {
      ε = 1;
      I = 1;
      I I e.N = <Add <Fib e.N> <Fib I e.N>>;
    }

Здесь (в порядке читерства) аргумент функции Фибоначчи представлен в единичной
системе счиления при помощи счётных палочек: `I`, `I I`, `I I I`…, результат
функции — как встроенный числовой тип данных Рефала.

Очевидно, что эта функция обладает экспоненциальной сложностью при вычислении
обычным интерпретатором. Посмотрим, как её будет вычислять наш интерпретатор.
Вычислим пятое число Фибоначчи:

    <Int
      ↓ <Go I I I I I>
      ,
      ↓ Go { e.N = <Fib e.N>; }
      ↓
      ↓ Fib {
      ↓   ε = 1;
      ↓   I = 1;
      ↓   I I e.N = <Add <Fib e.N> <Fib I e.N>>;
      ↓ }
    >













