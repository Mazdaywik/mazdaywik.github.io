_Александр Коновалов, сентябрь 2018_

Интертрепатор, снижающий сложность
==================================

В ходе обсуждения дистилляции с коллегами сложилась идея интерпретатора,
который может исполнять некоторые программы с меньшей алгоритмической
сложностью, нежели при прямолинейной интерпретации.

Изложение в данной работе будет вестись, как и прежде, **на интуитивных
основаниях,** но при этом промежуточные выкладки я буду стараться делать
строго формально, максимально избегаяя каких-либо натяжек.

Дальнейшее изложение будет вестись, как и в [предыдущей работе](essay.md),
в терминах перестановочного Рефала. И как и прежде, перестановочный Рефал
будет поддерживать многоместные функции как синтаксический сахар.

Обычный интерпретатор Рефала имеет две области памяти: поле программ, которое
не меняется при вычислениях, и поле зрения, описывающее текущее состояние
вычислений. Интерпретатор работает по шагам, заменяя на каждом шаге в поле
зрения активный вызов на его результат (согласно правилам, описанным в поле
программ). Вычисления завершаются, когда результат в поле зрения пассивен —
вызовов функций больше нет.

А если наоборот: написать интерпретатор, у которого в поле зрения ничего
интересного нет, но на каждом шаге переписывается поле программ?

> Сидит еврей, думает. Подходит другой.
> — Ты о чём думаешь?
> — Я думаю, зачем в слове «Мойша» буква «р».
> — Так её же там нет.
> — А если вставить?
> — А зачем?
> — Вот и я думаю: зачем?

Зачем писать такой интерпретатор? Размышления показывают, что он будет
обладать некоторыми интересными свойствами.

Аргументами интерпретатора являются начальное состояние поля зрения и исходная
программа:

    <Int  .......... , ....... >
          view-field   program

Для простоты будем считать, что интерпретатор по соглашению начинает своё
выполнение с функции `Go`, которая вызывается с некоторым аргументом:

    <Int ........ , ....... >
         <Go arg>   program

Обычный интерпретатор Рефала в данном случае стал бы переписывать поле зрения,
меняя на каждой итерации первый аргумент и сохраняя второй констатным.

Наш будет действовать иначе (почему? потому!). Он будет подготавливать программу
идеально к каждому следующему шагу. Как? Суперкомпиляцией. Но, если
суперкомпилятору «скормить» программу с константным аргументом, остаточная
программа просто будет функцией `Go`, возвращающей константу. Чтобы
суперкомпилятор выдал нетривиальную остаточную программу, нужно скормить ему
программу с параметрами. Поэтому интерпретатор вводит параметры:

    <Int-Loop ... ← ... , <Scp ........ , ....... >>
              arg   e.0        <Go e.0>   program

Суперкомпилятор порождает некоторую остаточную программу. Поскольку на первой
(а вернее, на нулевой) итерации программа специализировалась в общем положении,
результат суперкомпиляции может оказаться тривиальным — с точностью до порядка
и переименования функций и переменных совпадать с исходной программой.

Но смотрим, что дальше делает `Int-Loop`:

    <Int-Loop ......... , ........ , ........ >
              arg ← e.0   <F1 e.0>   program0

`Int-Loop` видит некоторую остаточную программу и точку входа в неё — функцию,
которая зависит от входного параметра. Возможны три случая:

1. Функция `F1` состоит из единственного предложения с пассивной правой
   частью. В этом случае интерпретатор просто подставляет в правую часть
   значение параметра и возвращает результат подстановки как результат.
2. В функции `F1` есть ветвление по различным сужениям параметра `e.0`.
3. В функции `F1` нет ветвления по параметру, поскольку где-то вылезло
   обобщение и построился let-узел. **Будем считать, что наш суперкомпилятор
   `Scp` никогда не обобщает «самый входной» параметр, а значит, третий
   случай никогда не реализуется.**

В первом случае мы имеем остановку интерпретатора с выдачей ответа.

Второй случай интереснее.

























