_Александр Коновалов, сентябрь 2018_

Интертрепатор, снижающий сложность
==================================

В ходе обсуждения дистилляции с коллегами сложилась идея интерпретатора,
который может исполнять некоторые программы с меньшей алгоритмической
сложностью, нежели при прямолинейной интерпретации.

Изложение в данной работе будет вестись, как и прежде, **на интуитивных
основаниях,** но при этом промежуточные выкладки я буду стараться делать
строго формально, максимально избегаяя каких-либо натяжек.

Дальнейшее изложение будет вестись, как и в [предыдущей работе](essay.md),
в терминах перестановочного Рефала. И как и прежде, перестановочный Рефал
будет поддерживать многоместные функции как синтаксический сахар.

Обычный интерпретатор Рефала имеет две области памяти: поле программ, которое
не меняется при вычислениях, и поле зрения, описывающее текущее состояние
вычислений. Интерпретатор работает по шагам, заменяя на каждом шаге в поле
зрения активный вызов на его результат (согласно правилам, описанным в поле
программ). Вычисления завершаются, когда результат в поле зрения пассивен —
вызовов функций больше нет.

А если наоборот: написать интерпретатор, у которого в поле зрения ничего
интересного нет, но на каждом шаге переписывается поле программ?

> Сидит еврей, думает. Подходит другой еврей.<br/>
> — Ты о чём думаешь?<br/>
> — Я думаю, зачем в слове «Мойша» буква «р».<br/>
> — Так её же там нет.<br/>
> — А если вставить?<br/>
> — А зачем?<br/>
> — Вот и я думаю: зачем?<br/>

Зачем писать такой интерпретатор? Размышления показывают, что он будет
обладать некоторыми интересными свойствами.

Аргументами интерпретатора являются начальное состояние поля зрения и исходная
программа:

    <Int  .......... , ....... >
          view-field   program

Для простоты будем считать, что интерпретатор по соглашению начинает своё
выполнение с функции `Go`, которая вызывается с некоторым аргументом:

    <Int ........ , ....... >
         <Go arg>   program

Обычный интерпретатор Рефала в данном случае стал бы переписывать поле зрения,
меняя на каждой итерации первый аргумент и сохраняя второй констатным.

Наш будет действовать иначе (почему? потому!). Он будет подготавливать программу
идеально к каждому следующему шагу. Как? Суперкомпиляцией. Но, если
суперкомпилятору «скормить» программу с константным аргументом, остаточная
программа просто будет функцией `Go`, возвращающей константу. Чтобы
суперкомпилятор выдал нетривиальную остаточную программу, нужно скормить ему
программу с параметрами. Поэтому интерпретатор вводит параметры:

    <Int-Loop (... ← ...) , <Scp ........ , ....... >>
               arg   e.0         <Go e.0>   program

Суперкомпилятор порождает некоторую остаточную программу. Поскольку на первой
(а вернее, на нулевой) итерации программа специализировалась в общем положении,
результат суперкомпиляции может оказаться тривиальным — с точностью до порядка
и переименования функций и переменных совпадать с исходной программой.

Но смотрим, что дальше делает `Int-Loop`:

    <Int-Loop (.........) , .... , ........ >
               arg ← e.0    expr   program0

`Int-Loop` видит некоторую остаточную программу и начальную конфигурацию.
Возможны три случая:

1. Выражение `expr` является пассивным, а `program0` — пустая. В этом случае
   интерпретатор просто подставляет в `expr` значение параметра и возвращает
   результат подстановки как результат.
2. Выражение `expr` содержит некоторые вызовы функций, зависящие от параметров.
   Будем считать, что `expr` имеет вид `<F1 e.0>`, а в функции `F1` есть
   ветвление по различным сужениям параметра `e.0`.
3. Выражение `expr` содержит вызовы функций, но нигде нет сужения для входных
   параметров.

**В первом случае** мы имеем остановку интерпретатора с выдачей ответа.

**Второй случай** интереснее. В остаточной программе параметр `e.0` будет падать
в функцию, где по нему будут выполняться одно или несколько сужений. Поскольку
мы используем перестановочный Рефал, все эти сужения будут независимы. Пусть
они имеют вид

    e.0 → P1
    e.0 → P2
    . . .
    e.0 → Pn

Интерпретатор применяет каждое из них к актуальному аргументу `arg`:

    arg : P1
    arg : P2
    . . .
    arg : Pn

Успешно может разрешиться не более одного клэша из нескольких. Если
не выполнился ни один, интерпретатор сообщает об ошибке невозможности
отождествления — аргумент не входит в область определения программы.

Успешно разрешившийся клэш присвоит значения переменным, входящим в `Pi`:

    arg1 ← v.1
    arg2 ← v.2
    . . .
    argK ← v.K

(Здесь `v` — это `s`, `t` или `e`.) Эти переменные и будут новыми параметрами,
а образец `Pi` — аргументом функции `F1` на следующую суперкомпиляцию:

    <Int-Loop (.... ← ...) … (.... ← ...) , <Scp ....... , ........ >>
               arg1   v.1     argK   v.K         <F1 Pi>   program0

    <Int-Loop (.... ← ...) … (.... ← ...), ................ , ........ >>
                                           <F1 v.1, …, v.K>   program1

В предельном случае `K` может оказаться равным нулю — образец `Pi` не содержит
переменных. В этом случае следующая суперкомпиляция просто проинтерпретирует
программу на константных данных и построит тривиальную программу из одного
предложения с пассивной правой частью. Этот случай соответствует корректной
остановке интерпретатора, мы его уже рассматривали.

Наконец, **третий случай** — сужений на параметры нет. Одной из причин может
быть бесконечная рекурсия вида

    Fi {
      EXPR = <Fi EXPR>
    }

В идеале суперкомпилятор должен обнаруживать в графе бесконечную рекурсию
и такие ветви отсекать. В таком случае интерпретатор будет видеть, что
граф (остаточная программа) пустой и выдавать сообщение об ошибке.

Другая причина — кривое обобщение, которое может быть как в корректной
программе, так и в зацикливающейся. Что может делать интерпретатор? Проще
всего «белый флаг» и начинать интерпретировать программу «по простому».
Либо искать какое-нибудь более интеллектуальное решение, например, строить
бесконечное дерево процесса до ближайшего ветвления. Понятно, что в обоих
случаях интерпретатор на зацикливающейся программе зависнет.

Можно ли научить суперкомпилятор никогда не обобщать входные параметры,
чтобы избежать третьего случая? Можно, но тогда сам суперкомпилятор рискует
зациклиться _(доказать не могу, чисто интуитивное предположение)._

В последующих примерах третий случай никогда не будет возникать. Рассмотрим
эти примеры.

### Соглашение о нотации MST-схем

Если аргументы функций на разных этажах схемы короткие, то их легко
изображать в строчку:

    <Int ........ , ....... >
         <Go arg>   program

Но если аргументы длинные, то схема удлиняется и перестаёт влезать в ширину
страницы:

    <Int ............................. , .................................. >
         <StartPointFunction argument>   the-better-program-for-interpreter

Строчки нижних этажей — это метакодированные выражения. Можно, используя
альтернативную нотацию (также представленную в текстах Турчина), записывать
так:

    <Int ↓{ <Go arg> }, ↓{ program }>

    <Int
      ↓{ <StartPointFunction argument> }
      ,
      ↓{ the-better-program-for-interpreter }
    >

Я буду записывать длинные метакодированные аргументы как строки, начинающиеся
со знака стрелки вниз, без фигурных скобок:

    <Int
      ↓ <StartPointFunction argument>
      ,
      ↓ the-better-program-for-iterpreter
    >

В последующих разделах нам потребуются приподнятые переменные:

    <Int ... e.X . , ....... >
         <Go  •  >   program

В «вертикальной нотации» приподнятые переменные будут окружаться знаками `#`:

    <Int
      ↓ <StartPointFunction #e.X#>
      ,
      ↓ the-better-program-for-interpreter
    >


Рекурсивное вычисление чисел Фибоначчи
--------------------------------------

Рассмотрим следующую программу:

    Go { e.N = <Fib e.N>; }

    Fib {
      ε = 1;
      I = 1;
      I I e.N = <Add <Fib e.N> <Fib I e.N>>;
    }

Здесь (в порядке читерства) аргумент функции Фибоначчи представлен в единичной
системе счиления при помощи счётных палочек: `I`, `I I`, `I I I`…, результат
функции — как встроенный числовой тип данных Рефала.

Очевидно, что эта функция обладает экспоненциальной сложностью при вычислении
обычным интерпретатором. Посмотрим, как её будет вычислять наш интерпретатор.
Вычислим пятое число Фибоначчи:

    <Int
      ↓ <Go I I I I I>
      ,
      ↓ Go { e.N = <Fib e.N>; }
      ↓
      ↓ Fib {
      ↓   ε = 1;
      ↓   I = 1;
      ↓   I I e.N = <Add <Fib e.N> <Fib I e.N>>;
      ↓ }
    >

Интерпретатор должен заменить аргумент на параметр и выполнить суперкомпиляцию
исходной программы:

    <Int-Loop
      (↓{I I I I I} ← ↓{e.0})
      ,
      <Scp
        ↓ <Go e.0>
        ,
        ↓ Go { e.N = <Fib e.N>; }
        ↓
        ↓ Fib {
        ↓   ε = 1;
        ↓   I = 1;
        ↓   I I e.N = <Add <Fib e.N> <Fib I e.N>>;
        ↓ }
      >
    >

Нетрудно убедиться, что суперкомпилятор воспроизведёт исходную программу
с точностью до имён функций и переменных:

    <Int-Loop
      (↓{I I I I I} ← ↓{e.0})
      ,
      ↓ <F1 e.0>
      ,
      ↓ F1 {
      ↓   ε = 1;
      ↓   I = 1;
      ↓   I I e.0 = <Add <F1 e.0> <F1 I e.0>>;
      ↓ }
    >

Параметр `e.0` падает на функцию `F1`, где имеются три различных сужения
аргумента:

    e.0 → ε
    e.0 → I
    e.0 → I I e.0

Строим клэши:

    I I I I I : ε        =>  fail
    I I I I I : I        =>  fail
    I I I I I : I I e.0  =>  I I I ← e.0

Последнее сужение применимо, делаем шаг:

    <Int-Loop
      (↓{I I I} ← ↓{e.0})
      ,
      <Scp
        ↓ <F1 I I e.0>
        ,
        ↓ F1 {
        ↓   ε = 1;
        ↓   I = 1;
        ↓   I I e.0 = <Add <F1 e.0> <F1 I e.0>>;
        ↓ }
      >
    >

Построим граф суперкомпиляции программы (очевидные транзитные шаги заменены
многоточием):

![7000-fibint.dot](7000-fibint.png)

Остаточная программа примет вид:

    F1 {
      ε = 2;
      I = 3;
      I I e.0 = <Add <F1 e.0> <F1 I e.0>>;
    }

Состояние интерпретатора:

    <Int-Loop
      (↓{I I I} ← ↓{e.0})
      ,
      ↓ <F1 e.0>
      ,
      ↓ F1 {
      ↓   ε = 2;
      ↓   I = 3;
      ↓   I I e.0 = <Add <F1 e.0> <F1 I e.0>>;
      ↓ }
    >

Шаг похож на предыдущий, имеем те же три сужения

    e.0 → ε
    e.0 → I
    e.0 → I I e.0

Строим клэши:

    I I I : ε        =>  fail
    I I I : I        =>  fail
    I I I : I I e.0  =>  I ← e.0

И новый шаг вычислений интерпретатора:

    <Int-Loop
      (↓{I} ← ↓{e.0})
      ,
      <Scp
        ↓ <F1 I I e.0>
        ,
        ↓ F1 {
        ↓   ε = 2;
        ↓   I = 3;
        ↓   I I e.0 = <Add <F1 e.0> <F1 I e.0>>;
        ↓ }
      >
    >

Граф суперкомпиляции (тут для наглядности транзитные шаги показаны полностью):

![7000-fibint.dot](7000-fibint.png)

Состояние интерпретатора:

    <Int-Loop
      (↓{I} ← ↓{e.0})
      ,
      ↓ <F1 e.0>
      ,
      ↓ F1 {
      ↓   ε = 5;
      ↓   I = 8;
      ↓   I I e.0 = <Add <F1 e.0> <F1 I e.0>>;
      ↓ }
    >

Программа подобна предыдущей, сужения на `e.0` те же. Клэши:

    I : ε        =>  fail
    I : I        =>  success
    I : I I e.0  =>  fail

Новых параметров нет. Строим новое состояние интерпретатора:

    <Int-Loop
      ε
      ,
      <Scp
        ↓ <F1 I>
        ,
        ↓ F1 {
        ↓   ε = 5;
        ↓   I = 8;
        ↓   I I e.0 = <Add <F1 e.0> <F1 I e.0>>;
        ↓ }
      >
    >

Даже граф суперкомпиляции строить не нужно, очевидно, что следующий шаг
примет вид:

    <Int-Loop
      ε
      ,
      ↓ 8
      ,
      ε
    >

Или в «горизонтальной форме»:

    <Int-Loop ε, . , ε>
                 8

(Понятно, что метакод от символа есть сам символ, но я для единообразия его
всё равно опустил.)

Начальная конфигурация пассивна, остаточная программа пустая. Интерпретатор
выдаёт ответ `8`.

Можно заметить, что на каждой итерации интерпретатор сокращает входной аргумент
на `I I`, а интерпретируемая программа остаётся подобной программе на предыдущем
шаге. Таким образом, продолжительность суперкомпиляции на каждом шаге в целом
константна, число шагов пропорционально длине аргумента. Следовательно,
**сложность работы интерпретатора — линейна от аргумента функции!**


Наивное обращение списка
------------------------

Рассмотрим простой алгоритм обращения лисповского списка:

* если список пустой — то его обращение пустое,
* если список непустой — то его обращение есть конкатенация обращения хвоста
  и списка из одной головы.

Cons-ячейку изобразим в виде `(t.Head t.Tail)`, пустой список — `NIL`.

Программа примет вид:

    nrev {
      (t.x t.xs) = <append <nrev t.xs> (t.x NIL)>;
      NIL = NIL;
    }

    append {
      (t.x t.xs) t.ys = (t.x <append t.xs t.ys>);
      NIL        t.ys = t.ys;
    }

Нетрудно показать, что программа имеет квадратичную сложность. Инвертируем
список из четырёх элементов:

    <nrev (1 (2 (3 (4 NIL))))>
    <append <nrev (2 (3 (4 NIL)))> (1 NIL)>
    <append <append <nrev (3 (4 NIL))> (2 NIL)> (1 NIL)>
    <append <append <append <nrev (4 NIL)> (3 NIL)> (2 NIL)> (1 NIL)>
    <append <append <append <append <nrev NIL> (4 NIL)> (3 NIL)> (2 NIL)> (1 NIL)>
    <append <append <append <append NIL (4 NIL)> (3 NIL)> (2 NIL)> (1 NIL)>
    <append <append <append (4 NIL) (3 NIL)> (2 NIL)> (1 NIL)>
    <append <append (4 <append NIL (3 NIL)>) (2 NIL)> (1 NIL)>
    <append <append (4 (3 NIL)) (2 NIL)> (1 NIL)>
    <append (4 <append (3 NIL) (2 NIL)>) (1 NIL)>
    <append (4 (3 <append NIL (2 NIL)>)) (1 NIL)>
    <append (4 (3 (2 NIL))) (1 NIL)>
    (4 <append (3 (2 NIL)) (1 NIL)>)
    (4 (3 <append (2 NIL) (1 NIL)>))
    (4 (3 (2 <append NIL (1 NIL)>)))
    (4 (3 (2 (1 NIL))))

16 шагов. Нетрудно убедиться, что для списка длины 5 мы получим 25 шагов.

Теперь интерпретируем нашим, суперкомпилирующим интерпретатором:

    <Int
      ! <nrev (1 (2 (3 (4 NIL))))>
      ,
      ! nrev {
      !   (t.x t.xs) = <append <nrev t.xs> (t.x NIL)>;
      !   NIL = NIL;
      ! }
      !
      ! append {
      !   (t.x t.xs) t.ys = (t.x <append t.xs t.ys>);
      !   NIL        t.ys = t.ys;
      ! }
    >

Нулевой шаг — ввод параметра и суперкомпиляция исходной программы:

    <Int-Loop
      (↓{(1 (2 (3 (4 NIL))))} ← ↓{t.0})
      ,
      <Scp
        ! <nrev t.0>
        ,
        ! nrev {
        !   (t.x t.xs) = <append <nrev t.xs> (t.x NIL)>;
        !   NIL = NIL;
        ! }
        !
        ! append {
        !   (t.x t.xs) t.ys = (t.x <append t.xs t.ys>);
        !   NIL        t.ys = t.ys;
        ! }
      >
    >

Суперкомпиляция повторит исходную программу с переименованием функций
и повышением местности.

    <Int-Loop
      (↓{(1 (2 (3 (4 NIL))))} ← ↓{t.0})
      ,
      ! <F1 t.0>
      ,
      ! F1 {
      !   (t.1 t.0) = <F2 <F1 t.0>, (t.1 NIL)>;
      !   NIL = NIL;
      ! }
      !
      ! F2 {
      !   (t.1 t.0), t.2 = (t.1 <F1 t.0, t.2>);
      !   NIL,       t.2 = t.2;
      ! }
    >

Для параметра `t.0` имеем сужения:

    t.0 → (t.1 t.0)
    t.0 → NIL

Строим клэши

    (1 (2 (3 (4 NIL)))) : (t.1 t.0) => 1 ← t.1, (2 (3 (4 NIL))) ← t.0
    (1 (2 (3 (4 NIL)))) : NIL       => fail

Делаем шаг:

    <Int-Loop
      (↓{1} ← ↓{t.1}) (↓{(2 (3 (4 NIL)))} ← ↓{t.0})
      ,
      <Scp
        ! <F1 (t.1 t.0)>
        ,
        ! F1 {
        !   (t.1 t.0) = <F2 <F1 t.0>, (t.1 NIL)>;
        !   NIL = NIL;
        ! }
        !
        ! F2 {
        !   (t.1 t.0), t.2 = (t.1 <F1 t.0, t.2>);
        !   NIL,       t.2 = t.2;
        ! }
      >
    >

Нетрудно показать, что суперкомпиляция нам даст такую остаточную программу:

    F1 {
      (t.1
    }
















